// DLL Sample Code - using lib_dll environment
//
// This file was generated by Visual Studio - and it shall have only minimal edit, if any at all
// For general safety, limit it to global variables initialization, or reading files at maximum,
// but no other DLL loading or starting threads.
//
// Changes Copyright [2016-2017] Secoh
//
// Licensed under the GNU General Public License, Version 3 or later versions (the "License")
// as published by the Free Software Foundation - see <http://www.gnu.org/licenses/>
// You may not use this file except in compliance with the License.
// Software is distributed on "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

#include "stdafx.h"
#include"../../loadlib.h"

// -------------------------------------------------------------------
//   It is safe and is recommended, to delete this entire file.
// -------------------------------------------------------------------
// 
// However, if autoinit is ever desired, you must add Linux-specific code
// to handle similar initialization when compiled and called in Linux environment.
//
// Below is the suggested method of doing this.
//
// Lets first define functions that do the startup/cleanup, and make them accessible from GCC/Linux:
//

void DLL_STARTUP dll_entry_point()    // startup and cleanup names can be any unique C names,
{                                     // the functions MUST be tagged for GCC as entry/exit
    printf("dll_entry\n");            // and functions shall NOT be static
}

void DLL_CLEANUP dll_exit_point()
{
    printf("dll_exit\n");
}

//
// Second, make Windows-only section with DLL initialization.
// Most of the code in this subsection is provided by Visual Studio.
// Changes are specifically marked below. Leave out items uncompatible with Linux:
//

#ifdef _WIN32


// dllmain.cpp : Defines the entry point for the DLL application.

BOOL APIENTRY DllMain( HMODULE hModule,
                       DWORD  ul_reason_for_call,
                       LPVOID lpReserved
					 )
{
	switch (ul_reason_for_call)
	{
	case DLL_PROCESS_ATTACH:   /* populate with startup call */   dll_entry_point(); break;
	case DLL_THREAD_ATTACH:
	case DLL_THREAD_DETACH:
	case DLL_PROCESS_DETACH:   /* populate with cleanup call */   dll_exit_point();
		break;
	}
	return TRUE;
}


#endif

